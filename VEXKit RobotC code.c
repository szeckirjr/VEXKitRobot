#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    IRsensorL,      sensorReflection)
#pragma config(Sensor, in2,    IRsensorR,      sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl3,  limitR,         sensorTouch)
#pragma config(Sensor, dgtl4,  limitL,         sensorTouch)
#pragma config(Sensor, dgtl5,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  AluminumL,      sensorTouch)
#pragma config(Sensor, dgtl8,  AluminumR,      sensorTouch)
#pragma config(Sensor, dgtl11, ledRed,         sensorDigitalOut)
#pragma config(Sensor, dgtl12, ledGreen,       sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motorRight,    tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motorLeft,     tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port3,           motorConnection, tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Eliada Ewa - V00921360
Tristen Schuh - V00919992
Eduardo Szeckir - V00921126
*/

/*=================================================================================
IMPORTANT OBSERVATIONS:
timer T1 is being used for monitorLightL
timer T2 is being used for monitorLightR
motorLeft is FASTER than motorRight (so speeds for right should be +10 than left)
====================================================================================*/


/*====================================================================
This is the following motor and sensor setup for our robot:
IRSensorL - left phototransistor
IRsensorR - right phototransistor
button1 - VEX bumper used as a button
button2 - VEX bumper used as a button
limitR - frontal right VEX limit switch
limitL - frontal left VEX limit switch
sonar - VEX Ultrasonic Range Finder
AluminumL - left back student-made aluminum bumper
AluminumR - right back student-made aluminum bumper
ledRed - red LED for output control
ledGreen - left LED for output control
motorRight - VEX 393 Motor that controls right drive (encoder I2C_1)
motorLeft - VEX 393 Motor that controls left drive (encoder I2C_2)
motorConnection - VEX 393 Motor that is used for the cable connection
======================================================================*/

// Creating variables and constant
// We have two different beacon_thresholds (one for each phototransistor)
// in case we need to change them separetely
const int beacon_thresholdFar = 200;
const int beacon_thresholdClose = 900;
bool button1_pushed;
bool button2_pushed;
bool limitR_pushed;
bool limitL_pushed;
bool AluminumL_pushed;
bool AluminumR_pushed;

//===================================================================================================

// Function to monitor sensor inputs
// It gets SensorValues from sensors and updates their pushed flag to true
void monitorInput(){

	if(SensorValue(button1) && !button1_pushed){
		button1_pushed = true;
	}//if

	if(SensorValue(button2) && !button2_pushed){
		button2_pushed = true;
	}//if

	if(SensorValue(limitL) && !limitL_pushed){
		limitL_pushed = true;
	}//if

	if(SensorValue(limitR) && !limitR_pushed){
		limitR_pushed	= true;
	}//if

	if(SensorValue(AluminumL) && !AluminumL_pushed){
		AluminumL_pushed = true;
	}
	if(SensorValue(AluminumR) && !AluminumR_pushed){
		AluminumR_pushed = true;
	}//if

}//monitorInput

//===============================================================================================================

// Function to monitor light in left phototransistor
// Function gotten from ENGR 120 slides

int monitorLightL()
{

	static int minLevelIRL = 4096;	// Minimum light level seen by IR sensor L
	static int maxLevelIRL = 0;			// Maximum light level seen by IR sensor L
	static int diffLevelIRL = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevelL = SensorValue[IRsensorL];

	// Check if 100 msecs have elapsed.
	// This is to take into acount the frequency of 10Hz of the beacon
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIRL = maxLevelIRL - minLevelIRL;

		// Reset calculation for next 100 msecs.
		maxLevelIRL = 0;
		minLevelIRL = 4096;
		clearTimer(T1);

	}//if

	else {

		// Check for new minimum/maximum light levels.
		if ( lightLevelL < minLevelIRL ) {
			minLevelIRL = lightLevelL;
		}
		else if ( lightLevelL > maxLevelIRL ) {
			maxLevelIRL = lightLevelL;
		}
	}//else

	return (diffLevelIRL);
}//monitorLightL

// Function to monitor light in right phototransistor
// Function gotten from ENGR 120 slides
int monitorLightR()
{

	static int minLevelIRR = 4096;	// Minimum light level seen by IR sensor R
	static int maxLevelIRR = 0;			// Maximum light level seen by IR sensor R
	static int diffLevelIRR = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevelR = SensorValue[IRsensorR];

	// Check if 100 msecs have elapsed.
	// This is to take into acount the frequency of 10Hz of the beacon
	if ( time1[T2] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIRR = maxLevelIRR - minLevelIRR;

		// Reset calculation for next 100 msecs.
		maxLevelIRR = 0;
		minLevelIRR = 4096;
		clearTimer(T2);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevelR < minLevelIRR ) {
			minLevelIRR = lightLevelR;
			} else if ( lightLevelR > maxLevelIRR ) {
			maxLevelIRR = lightLevelR;
		}
	}

	return (diffLevelIRR);
}//monitorLightR

//==============================================================================================================

//Creation of robot_state cases
enum T_robot_state {
	STOP = 0,
	SEARCH,
	FIX_DIRECTION,
	APPROACH,
	AVOID_WALL,
	CONNECT,
	LEAVE
};

T_robot_state robot_state = STOP;

//=============================================================================================================

task main(){


	motor[motorLeft]=0;
	motor[motorRight]=0;
	resetMotorEncoder(motorLeft);
	resetMotorEncoder(motorRight);
	motor[motorConnection]=0;
	button1_pushed=button2_pushed=limitL_pushed=limitR_pushed=false;
	AluminumL_pushed = AluminumR_pushed = false;
	SensorValue(ledGreen)=SensorValue(ledRed)=0;
	robot_state = STOP;
	int k = 0;

	while(true){

		monitorInput();
		int lightLeft = monitorLightL();
		int lightRight = monitorLightR();
		int distance = SensorValue(sonar);
		int ticksLeft = getMotorEncoder(motorLeft);
		int ticksRight = getMotorEncoder(motorRight);

		if(button1_pushed){
			button1_pushed = false;
			robot_state = SEARCH;
		}

		if(button2_pushed){
			button2_pushed = false;
			robot_state = STOP;
		}
		//=============================================================================================================

		switch(robot_state){
			//=============================================================================================================
		case STOP:
			SensorValue(ledRed) = 0;
			SensorValue(ledGreen) = 0;
			motor[motorLeft]=motor[motorRight]=motor[motorConnection]=0;
			break;
			//=============================================================================================================
		case SEARCH:

			SensorValue(ledRed) = 0;
			SensorValue(ledGreen) = 0;

			if(distance>100){

				if((lightLeft>=beacon_thresholdFar) && (lightRight>=beacon_thresholdFar)){
					motor[motorLeft]=motor[motorRight]=0;
					robot_state = APPROACH;
					break;
				}//if

				else if(lightRight>lightLeft+140){
					motor[motorLeft] = 40;
					motor[motorRight] = -48;
					break;
				}

				else if(lightLeft>lightRight+140){
					motor[motorLeft] = -40;
					motor[motorRight] = 48;
					break;
				}

				else{
					motor[motorLeft]=40;
					motor[motorRight]=-48;
				}

			}

			else if(distance<=100){

				if((lightLeft>=beacon_thresholdClose) && (lightRight>=beacon_thresholdClose)){
					motor[motorLeft]=motor[motorRight]=0;
					robot_state = APPROACH;
					break;
				}//if

				else if(lightRight>lightLeft+140){
					motor[motorLeft] = 40;
					motor[motorRight] = -48;
					break;
				}

				else if(lightLeft>lightRight+140){
					motor[motorLeft] = -40;
					motor[motorRight] = 48;
					break;
				}

				else{
					motor[motorLeft]=40;
					motor[motorRight]=-48;
				}

			}

			break;
			//=============================================================================================================
		case APPROACH:

			SensorValue(ledRed) = 1;
			SensorValue(ledGreen) = 0;

			if(distance<90 && k==0){
				k=1;
				robot_state = SEARCH;
				break;
			}
			else{
				motor[motorLeft]=40;
				motor[motorRight]=65;
			}

			if((distance<=12) && (lightLeft>=beacon_thresholdClose) && (lightRight>=beacon_thresholdClose)){
				motor[motorLeft]=motor[motorRight]=0;
				robot_state = FIX_DIRECTION;
				break;
			}

			else if((distance<40) && ((lightLeft<beacon_thresholdClose) || (lightRight<beacon_thresholdClose))){
				motor[motorLeft]=motor[motorRight]=0;
				robot_state = AVOID_WALL;
				break;
			}

			if(limitL_pushed || limitR_pushed){
				motor[motorLeft]=motor[motorRight]=0;
				robot_state = AVOID_WALL;
				break;
			}

			break;
			//=============================================================================================================
		case FIX_DIRECTION:

			SensorValue(ledRed) = 1;
			SensorValue(ledGreen) = 0;

			if(lightLeft>lightRight+140){
				motor[motorLeft]=-40;
				motor[motorRight]=48;
				break;
			}
			else if(lightLeft<lightRight-140){
				motor[motorLeft]=40;
				motor[motorRight]=-48;
				break;
			}
			else if(lightLeft>=lightRight-50 && lightLeft<=lightRight+50){
				motor[motorLeft]=motor[motorRight]=0;
				robot_state = CONNECT;
				break;
			}

			break;
			//=============================================================================================================
		case AVOID_WALL:

			SensorValue(ledRed) = 0;
			SensorValue(ledGreen) = 0;

			if(distance<40){
				limitL_pushed = limitR_pushed = false;
				motor[motorLeft]=-40;
				motor[motorRight]=-50;
				delay(1000);
				motor[motorLeft]=40;
				motor[motorRight]=-48;
				delay(1000);
				robot_state = SEARCH;
				break;
			}

			if(limitL_pushed){
				limitL_pushed = false;
				resetMotorEncoder(motorLeft);
				resetMotorEncoder(motorRight);
				motor[motorLeft]=-127;
				motor[motorRight]=-30;
			}

			if(limitR_pushed){
				limitR_pushed = false;
				resetMotorEncoder(motorLeft);
				resetMotorEncoder(motorRight);
				motor[motorLeft]=-30;
				motor[motorRight]=-127;
			}

			if(AluminumL_pushed || AluminumR_pushed){
				AluminumL_pushed = AluminumR_pushed = false;
				resetMotorEncoder(motorLeft);
				resetMotorEncoder(motorRight);
				motor[motorLeft]=40;
				motor[motorRight]=50;
				break;
			}

			else if((ticksLeft<-500 || ticksRight>500) || (ticksLeft>500 || ticksRight<-500)){
				motor[motorLeft]=motor[motorRight]=0;
				robot_state = SEARCH;
				break;
			}

			break;
			//=============================================================================================================
		case CONNECT:
			SensorValue(ledRed) = 1;
			SensorValue(ledGreen) = 0;
			motor[motorConnection]=70;
			delay(4500);
			motor[motorConnection]=0;
			robot_state = LEAVE;
			break;
			//=============================================================================================================
		case LEAVE:

			SensorValue(ledRed) = 0;
			SensorValue(ledGreen) = 1;

			motor[motorLeft] = -45;
			motor[motorRight] = -55;
			delay(2500);
			motor[motorLeft] = 45;
			motor[motorRight] = -55;
			delay(1000);

			while(!AluminumL_pushed || !AluminumR_pushed){
				motor[motorLeft]= -45;
				motor[motorRight] = -55;
				monitorInput();
			}

			motor[motorLeft]=motor[motorRight]=0;
			robot_state = STOP;

			break;
			//=============================================================================================================
		default:
			robot_state = STOP;

		}//switch

	}//while(true)

}//task main
